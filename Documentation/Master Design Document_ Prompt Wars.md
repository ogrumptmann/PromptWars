# **Master Design Document: Prompt Wars**

Version: 4.0 (Consolidated with Implementation Roadmap)  
Owner: VP of Engineering  
Concept: "Prompt Wars" \- A Text-based Strategy Game powered by Generative AI.  
Core Stack: React (Frontend) \+ Python FastAPI (Backend) \+ LLM (Referee).

## **1\. Technical Standards & Guidelines (AI-Optimized)**

*Crucial: These rules are designed to minimize AI hallucinations and integration errors.*

### **1.1 Python Backend (FastAPI)**

* **Strict Typing:** All function arguments and return types **must** be typed.  
* **Pydantic Everything:** Never pass raw dictionaries. Use Pydantic models for all API inputs/outputs.  
* **Docstrings:** Every function must have a docstring describing *what* it does, not *how*.  
* **Repository Pattern:** Keep database logic (Redis) separate from Game Logic.  
* **LLM Agnosticism:** Game logic must NEVER import provider-specific libraries (e.g., openai, google-generativeai). specific logic must be isolated in app/providers.

### **1.2 React Frontend**

* **Functional Components:** Use React Hooks only. No Class components.  
* **Tailwind CSS:** Do not write custom CSS files. Use utility classes (e.g., flex flex-col h-screen).  
* **State Management:** Use Zustand for global game state.  
* **PixiJS:** Isolate all canvas logic into specific \<Arena /\> components.

### **1.3 AI Prompting Strategy**

* **Context First:** When asking the AI to code, always provide the Pydantic Model (Section 6\) first.

## **2\. Technology Stack Definition**

| Component | Technology | Rationale |
| :---- | :---- | :---- |
| **Frontend** | React 19 \+ Vite | Standard, fast, robust. |
| **Styling** | Tailwind CSS | Rapid UI development. |
| **Graphics** | PixiJS (@pixi/react) | High perf 2D particles/sprites. |
| **Backend** | Python 3.11+ (FastAPI) | Native Async support, best AI libs. |
| **Realtime** | WebSocket (FastAPI native) | Low latency game state sync. |
| **Database** | Redis | Ephemeral game state \+ **Sorted Sets for Leaderboards**. |
| **AI Layer** | **Configurable Adapter** | Support OpenAI, Gemini, and Local (Ollama). |
| **Infra** | Docker / Azure Container Apps | Easy deployment. |

## **3\. Detailed Game Flow Specification (State Machine)**

Core Loop Type: Simultaneous Turn-Based (We-Go).  
Both players plan secretly, then actions resolve simultaneously.

### **State 1: MATCH\_START / NEW\_TURN**

1. **Entry Points:**  
   * **Manual:** Player joins via JOIN\_ROOM with a specific code.  
   * **Matchmaker:** Player enters queue via FIND\_MATCH. Server pairs them and creates a room.  
2. **Cleanup:** Server clears previous turn data in Redis.  
3. **Draw Phase:** Server generates 3 **NEW** random Constraint Cards for each player.  
   * *Pool Source:* See Section 8 (Registry).  
4. **Transition:** Auto-transition to INPUT\_PHASE.

### **State 2: INPUT\_PHASE (Duration: 45s)**

1. **Client UI:** Displays the 3 new cards.  
2. **Blind Input:** Player A cannot see if Player B has typed anything.  
3. **Commit:** Player selects 1 Card \+ types Prompt \-\> Clicks "Cast".  
4. **Lock:** Once committed, the UI locks. The player sees "Waiting for Opponent...".  
5. **Timeout:** If timer hits 0 and a player hasn't committed, they enter a FIZZLE state automatically.  
6. **Transition:** When both committed OR time expires \-\> PROCESSING\_PHASE.

### **State 3: PROCESSING\_PHASE (Duration: \~3-5s)**

1. **AI Arbitration (Strict Mode):**  
   * The Server sends both prompts \+ selected cards \+ **Current Environment** to the LLM.  
   * **Validation Rule:** The LLM is instructed to fail mismatches (e.g., Card='Fire' vs Prompt='Ice').  
2. **Resolution:**  
   * If both valid: Calculate interaction (e.g., Water douses Fire).  
   * **Environment Update:** The AI decides if the environment changes (e.g., "Forest" \-\> "Burning Forest").  
3. **Transition:** Server broadcasts TURN\_RESULT event \-\> PLAYBACK\_PHASE.

### **State 4: PLAYBACK\_PHASE (Duration: \~5-10s)**

1. **Client Action:**  
   * Step 1: Reveal Opponent's Text.  
   * Step 2: Trigger PixiJS emitters (Visuals generated by AI).  
   * Step 3: Apply HP changes.  
   * Step 4: Update Environment Label (if changed).  
2. **Win Check:**  
   * If Player A HP \<= 0: Player B Wins.  
   * If Player B HP \<= 0: Player A Wins.  
   * If Both \<= 0: Draw.  
3. **End Game Trigger:**  
   * If Win/Loss detected: Server calculates **Elo Updates** and sends GAME\_OVER.  
   * Else: Go to State 1 (New Turn).

## **4\. Product Backlog (Phased)**

### **Phase 1: The "Text Console" (MVP Core)**

*Goal: Play a full game in text only. Prove the AI Judge works.*

**Epic 1.1: Project Skeleton**

* \[ \] **Task 1:** Initialize React repo (Vite \+ Tailwind).  
* \[ \] **Task 2:** Initialize Python repo (FastAPI \+ Poetry/Pip).  
* \[ \] **Task 3:** Setup basic Docker Compose (Frontend \+ Backend \+ Redis).

**Epic 1.2: The AI Judge Service (Strict Mode)**

* \[ \] **Task 4:** Create Pydantic Models (See Section 6).  
* \[ \] **Task 5:** Implement LLMProvider Abstract Base Class (Adapter Pattern).  
* \[ \] **Task 6:** Implement OpenAIProvider, GeminiProvider, and LocalProvider.  
* \[ \] **Task 7:** Create "System Prompt" with Few-Shot Examples (See Section 7).

**Epic 1.3: Basic Game Loop (Single Player/Dev Mode)**

* \[ \] **Task 8:** Create API Endpoint /submit\_turn.  
* \[ \] **Task 9:** Frontend: Create simple Form input \+ Log display.  
* \[ \] **Task 10:** Connect Frontend to API. Display raw JSON response from AI.

**Epic 1.4: Card Logic**

* \[ \] **Task 19:** Create cards.json registry file (See Section 8).  
* \[ \] **Task 20:** Implement CardService in Python to draw random cards.

### **Phase 2: The Visuals (PixiJS)**

*Goal: Turn text data into visual feedback.*

**Epic 2.1: The Arena**

* \[ \] **Task 11:** Integrate react-pixi. Create a black canvas background.  
* \[ \] **Task 12:** Create PlayerAvatar component (Simple shapes: Triangle/Square).

**Epic 2.2: Generative Particle Engine**

* \[ \] **Task 13:** Create a generic ParticleEmitter component in PixiJS.  
* \[ \] **Task 14:** Update AI Judge Pydantic model to include visual\_config.  
* \[ \] **Task 15:** Map AI JSON output to ParticleEmitter props.

### **Phase 5: Progression & Matchmaking (New)**

*Goal: Add persistence, competition, and automated pairing.*

**Epic 5.1: The Leaderboard**

* \[ \] **Task 24:** Implement Redis ZSET logic for global\_leaderboard.  
* \[ \] **Task 25:** Implement Elo Calculation Logic (K-Factor algorithm).  
* \[ \] **Task 26:** Create API /api/leaderboard (Top 100).  
* \[ \] **Task 27:** Frontend: Create "World Rank" Screen.

**Epic 5.2: Matchmaking Service**

* \[ \] **Task 28:** Implement MatchmakingService (Redis List/Queue).
  * Logic: Simple FIFO for MVP. (Bonus: Buckets by Elo \+/- 200).
* \[ \] **Task 29:** WebSocket: Handle FIND\_MATCH and CANCEL\_MATCH.
* \[ \] **Task 30:** Frontend: Add "Play Now" vs "Private Game" toggle.

### **Phase 6: AI-Generated Battle Replay Videos (Post-Game Feature)**

*Goal: Transform battle data into cinematic replay videos in the style of classic Japanese RPG battles (Final Fantasy, Dragon Quest).*

**Epic 6.1: Battle Data Persistence**

* \[ \] **Task 31:** Extend BattleResult model to include full battle context:
  * Player prompts and selected cards for each turn
  * AI judge reasoning/narrative for each turn
  * Damage dealt, HP changes, visual effects
  * Environment state changes
  * Timestamps for each turn
* \[ \] **Task 32:** Implement BattleHistoryService to persist complete battle data in Redis:
  * Key structure: `battle_history:{game_id}` with TTL (7 days)
  * Store as JSON with all turn data, player names, final outcome
* \[ \] **Task 33:** Create API endpoint `/api/battles/{game_id}/replay-data`:
  * Returns complete battle history in structured format
  * Includes all prompts, cards, AI narratives, and visual effects

**Epic 6.2: AI Video Script Generation**

* \[ \] **Task 34:** Create VideoScriptService that uses LLM to generate video script:
  * Input: Complete battle history from Task 32
  * Output: Structured video script with:
    * Scene descriptions for each turn
    * Camera angles and transitions
    * Character animations (attack, defend, hurt, victory)
    * Visual effect timings and intensities
    * Background music cues
* \[ \] **Task 35:** Design video script Pydantic model:
  * `VideoScript` with list of `Scene` objects
  * Each `Scene` includes: duration, camera_angle, character_actions, effects, narration
  * Style parameters: "classic_jrpg", "pixel_art", "anime_style"
* \[ \] **Task 36:** Implement LLM prompt for video generation:
  * System prompt: "You are a video director for classic JRPG battle scenes..."
  * Include examples of Final Fantasy battle cinematography
  * Ensure output matches structured format

**Epic 6.3: Video Generation Integration**

* \[ \] **Task 37:** Research and select video generation API:
  * Options: Runway ML, Pika Labs, Stability AI Video, or custom Stable Diffusion Video
  * Evaluate: cost per video, generation time, style control, API reliability
* \[ \] **Task 38:** Create VideoGenerationService (Adapter Pattern):
  * Abstract base class for video generation providers
  * Implement provider-specific adapters (similar to LLM providers)
  * Handle async video generation (webhook callbacks)
* \[ \] **Task 39:** Implement video generation pipeline:
  * Convert VideoScript to provider-specific prompts
  * Generate video segments for each battle turn
  * Stitch segments together with transitions
  * Add background music and sound effects
  * Store final video in cloud storage (Azure Blob / S3)

**Epic 6.4: Replay UI & Sharing**

* \[ \] **Task 40:** Create "Generate Replay Video" button on game over screen:
  * Show estimated generation time (2-5 minutes)
  * Display progress indicator with status updates
  * Use WebSocket to notify when video is ready
* \[ \] **Task 41:** Create VideoReplayModal component:
  * Embedded video player
  * Download button
  * Share to social media (Twitter, Discord, Reddit)
  * Copy shareable link
* \[ \] **Task 42:** Implement video gallery/history:
  * `/profile/replays` page showing user's generated videos
  * Thumbnail previews
  * View count and likes (optional social features)
* \[ \] **Task 43:** Add video metadata and SEO:
  * Generate thumbnail from first frame
  * Add title: "Epic Battle: [Player1] vs [Player2]"
  * Include battle stats in description
  * Open Graph tags for social sharing

**Epic 6.5: Style Customization & Polish**

* \[ \] **Task 44:** Implement style selection UI:
  * Classic JRPG (Final Fantasy 6-9 style)
  * Pixel Art (16-bit retro)
  * Modern Anime (Final Fantasy 7 Remake style)
  * Chibi/Cute style
* \[ \] **Task 45:** Add video customization options:
  * Battle speed (slow-mo, normal, fast)
  * Music selection (epic, dramatic, upbeat)
  * Include/exclude AI narration voiceover
  * Add player commentary text overlays
* \[ \] **Task 46:** Implement video caching and optimization:
  * Cache generated videos for 30 days
  * Compress videos for web delivery
  * Generate multiple resolutions (480p, 720p, 1080p)
  * Add watermark with game logo (optional)

**Technical Considerations:**

* **Cost Management:** Video generation can be expensive. Consider:
  * Free tier: 1 video per day per user
  * Premium tier: Unlimited videos
  * Queue system to manage API rate limits
* **Generation Time:** Videos may take 2-10 minutes to generate:
  * Use async job queue (Celery or Redis Queue)
  * Send email/push notification when ready
  * Show estimated completion time
* **Storage:** Videos can be large (50-200MB):
  * Use cloud storage with CDN
  * Implement automatic cleanup after 30 days
  * Offer download before deletion
* **Quality Control:** AI-generated videos may have artifacts:
  * Implement review/regenerate option
  * Allow users to report issues
  * Consider human review for featured videos

**Success Metrics:**

* % of players who generate at least one replay video
* Average videos generated per active player
* Social shares and viral coefficient
* User retention impact (players who generate videos vs those who don't)
* Video generation cost per user

## **5\. UI Specification & Component Tree**

**Visual Layout (Portrait Mode \- Mobile First)**

\+------------------------------------------+  
|  \[Header\] Round 3 | Timer: 00:24         |  
\+------------------------------------------+  
|                                          |  
|            OPPONENT (HP: 85\)             |  
|           \[Red Triangle Avatar\]          |  
|                                          |  
|               ARENA ZONE                 |  
|      (PixiJS Canvas \- 50% Height)        |  
|                                          |  
|           \[Blue Square Avatar\]           |  
|             PLAYER (HP: 60\)              |  
|                                          |  
\+------------------------------------------+  
|  \[Log\]                                   |  
|  \> Opponent cast "Fireball"              |  
|  \> You cast "Ice Wall"                   |  
\+------------------------------------------+  
|  \[Hand of Cards\]                         |  
|  \+-------+  \+-------+  \+-------+         |  
|  | FIRE  |  |DEFEND |  |METAL  |         |  
|  \+-------+  \+-------+  \+-------+         |  
\+------------------------------------------+  
|  \[Input\] "I shoot a fire arrow..."       |  
|  \[CAST BUTTON\]                           |  
\+------------------------------------------+

**React Component Tree**

1. App (Layout wrapper)  
2. GameContainer (Manages WebSocket & Zustand State)  
   * Header (Round \#, Timer)  
   * Arena (PixiJS Stage)  
     * Avatar (Player/Opponent)  
     * ParticleLayer (Renders AI visual effects)  
   * BattleLog (Text history)  
   * ActionPanel (Bottom controls)  
     * CardHand (Displays 3 clickable cards)  
     * PromptInput (Text area \+ Submit)

## **6\. API Contract (Data Models)**

*Use these Pydantic models for Backend definitions and Frontend Interfaces.*

from pydantic import BaseModel  
from typing import List, Literal, Optional

class CardDefinition(BaseModel):  
    id: str  
    display\_name: str  
    type: Literal\["ELEMENT", "ACTION", "MATERIAL"\]  
    description: str  \# Instructions for the user  
    ai\_validation\_rule: str \# Instructions for the AI Judge

class PlayerMove(BaseModel):  
    player\_id: str  
    selected\_card\_id: str  
    prompt\_text: str

class VisualEffect(BaseModel):  
    target: Literal\["self", "opponent", "center"\]  
    color\_hex: str  
    shape: Literal\["circle", "square", "spark"\]  
    count: int  
    movement\_pattern: Literal\["explode", "beam", "rain"\]

class TurnResult(BaseModel):  
    narrative: str  
    damage\_dealt\_to\_opponent: int  
    self\_damage: int \# Used for "Fizzle" or backlash  
    visuals: List\[VisualEffect\]  
    is\_valid\_move: bool  
    environment\_update: Optional\[str\] \# E.g., "The arena is now frozen."

class LeaderboardEntry(BaseModel):  
    rank: int  
    player\_id: str  
    elo\_rating: int  
    wins: int  
    losses: int

## **7\. System Prompt Draft (The AI Judge)**

ROLE:  
You are the Referee of "Prompt Wars". Your job is to judge a magic battle strictly.

INPUTS:  
1\. Card Selected: {card\_name} (Rule: {ai\_validation\_rule})  
2\. Prompt: {user\_prompt}  
3\. Current Environment: {env\_description}

STRICT VALIDATION (The "Fizzle" Check):  
Check if the user's prompt adheres to the Card Rule.  
\- If Card is "FIRE" and prompt is "I stab him", result is INVALID (Self-damage 10).  
\- If Card is "DEFEND" and prompt is "I throw a fireball", result is INVALID.

LOGIC & PHYSICS:  
\- Water \> Fire.  
\- Shield \> Arrow.  
\- Void \> Matter.

FEW-SHOT EXAMPLES:

Example 1 (Success):  
Card: "Blaze (Fire)"  
Prompt: "I hurl a spear of magma."  
Result: { "is\_valid\_move": true, "narrative": "The magma spear strikes...", "damage\_dealt\_to\_opponent": 25, "visuals": \[{"color\_hex": "\#FF4500", "shape": "spark"}\] }

Example 2 (Fizzle/Fail):  
Card: "Blaze (Fire)"  
Prompt: "I splash water on him."  
Result: { "is\_valid\_move": false, "narrative": "You try to summon water but your Fire rune backfires\!", "self\_damage": 10 }

Example 3 (Environment):  
Card: "Frost (Ice)"  
Environment: "Flooded"  
Prompt: "I freeze the water on the ground."  
Result: { "is\_valid\_move": true, "narrative": "The floodwaters freeze solid, trapping the opponent.", "environment\_update": "Frozen Lake" }

OUTPUT:  
Return strict JSON matching the TurnResult schema.

## **8\. Game Content (The Card Registry)**

*This data will be stored in backend/app/data/registry.json.*

\[  
  {  
    "id": "c\_fire",  
    "display\_name": "Blaze",  
    "type": "ELEMENT",  
    "description": "Invoke the power of heat and flame.",  
    "ai\_validation\_rule": "Must involve heat, fire, lava, or burning."  
  },  
  {  
    "id": "c\_ice",  
    "display\_name": "Frost",  
    "type": "ELEMENT",  
    "description": "Freeze your opponent or create barriers.",  
    "ai\_validation\_rule": "Must involve cold, ice, snow, or freezing."  
  },  
  {  
    "id": "c\_water",  
    "display\_name": "Aqua",  
    "type": "ELEMENT",  
    "description": "Use water to douse or drown.",  
    "ai\_validation\_rule": "Must involve water, rain, steam, or liquid."  
  },  
  {  
    "id": "c\_stone",  
    "display\_name": "Geo",  
    "type": "ELEMENT",  
    "description": "Crush with earth or build walls.",  
    "ai\_validation\_rule": "Must involve rocks, earth, sand, or weight."  
  },  
  {  
    "id": "c\_wind",  
    "display\_name": "Gale",  
    "type": "ELEMENT",  
    "description": "Blow them away or create vacuums.",  
    "ai\_validation\_rule": "Must involve air, wind, tornados, or gas."  
  },  
  {  
    "id": "c\_elec",  
    "display\_name": "Volt",  
    "type": "ELEMENT",  
    "description": "Shock or stun with electricity.",  
    "ai\_validation\_rule": "Must involve lightning, electricity, or sparks."  
  },  
  {  
    "id": "c\_void",  
    "display\_name": "Shadow",  
    "type": "ELEMENT",  
    "description": "Use gravity or darkness.",  
    "ai\_validation\_rule": "Must involve darkness, void, emptiness, or gravity."  
  },  
  {  
    "id": "c\_light",  
    "display\_name": "Solar",  
    "type": "ELEMENT",  
    "description": "Blind or burn with pure light.",  
    "ai\_validation\_rule": "Must involve light, lasers, flash, or blinding."  
  },  
  {  
    "id": "c\_sound",  
    "display\_name": "Sonic",  
    "type": "ELEMENT",  
    "description": "Shatter with soundwaves.",  
    "ai\_validation\_rule": "Must involve sound, music, screams, or vibration."  
  },  
  {  
    "id": "c\_toxin",  
    "display\_name": "Venom",  
    "type": "ELEMENT",  
    "description": "Poison or corrode.",  
    "ai\_validation\_rule": "Must involve poison, acid, decay, or sickness."  
  },  
  {  
    "id": "c\_guard",  
    "display\_name": "Shield",  
    "type": "ACTION",  
    "description": "Protect yourself from damage.",  
    "ai\_validation\_rule": "Must be defensive. Cannot deal direct damage."  
  },  
  {  
    "id": "c\_strike",  
    "display\_name": "Melee",  
    "type": "ACTION",  
    "description": "A direct physical hit.",  
    "ai\_validation\_rule": "Must involve a physical weapon or punch. No magic."  
  },  
  {  
    "id": "c\_shot",  
    "display\_name": "Range",  
    "type": "ACTION",  
    "description": "Attack from a distance.",  
    "ai\_validation\_rule": "Must involve projectiles, bows, or throwing."  
  },  
  {  
    "id": "c\_trap",  
    "display\_name": "Snare",  
    "type": "ACTION",  
    "description": "Set a hidden danger.",  
    "ai\_validation\_rule": "Must set a trap or involve deception/hidden threats."  
  },  
  {  
    "id": "c\_heal",  
    "display\_name": "Mend",  
    "type": "ACTION",  
    "description": "Restore health or repair armor.",  
    "ai\_validation\_rule": "Must involve healing, repair, or regeneration."  
  },  
  {  
    "id": "c\_dash",  
    "display\_name": "Haste",  
    "type": "ACTION",  
    "description": "Move quickly or dodge.",  
    "ai\_validation\_rule": "Must involve speed, movement, or dodging."  
  },  
  {  
    "id": "c\_steel",  
    "display\_name": "Iron",  
    "type": "MATERIAL",  
    "description": "Use metal objects.",  
    "ai\_validation\_rule": "Must summon or manipulate metallic objects."  
  },  
  {  
    "id": "c\_wood",  
    "display\_name": "Nature",  
    "type": "MATERIAL",  
    "description": "Use organic plant matter.",  
    "ai\_validation\_rule": "Must involve plants, vines, wood, or flowers."  
  },  
  {  
    "id": "c\_glass",  
    "display\_name": "Crystal",  
    "type": "MATERIAL",  
    "description": "Use fragile but sharp shards.",  
    "ai\_validation\_rule": "Must involve glass, mirrors, prisms, or shards."  
  },  
  {  
    "id": "c\_tech",  
    "display\_name": "Cyber",  
    "type": "MATERIAL",  
    "description": "Use futuristic technology.",  
    "ai\_validation\_rule": "Must involve circuitry, holograms, or code."  
  }  
\]

## **9\. WebSocket Protocol (Event Schema)**

*Define exactly how Server and Client communicate in real-time.*

**Client \-\> Server**

* JOIN\_ROOM: { "player\_id": "...", "room\_id": "..." }  
* FIND\_MATCH: { "player\_id": "..." } (Enters matchmaking queue)  
* CANCEL\_MATCH: { "player\_id": "..." }  
* RECONNECT: { "player\_id": "...", "room\_id": "..." }

**Server \-\> Client**

* ERROR: { "code": "ROOM\_FULL" | "GAME\_NOT\_FOUND", "message": "..." }  
* MATCH\_FOUND: { "opponent\_id": "...", "room\_id": "...", "current\_round": 1 }  
* GAME\_STATE\_SYNC: { "player\_hp": 100, "opponent\_hp": 100, "round": 1, "history": \[...\] } (Sent on reconnect)  
* TURN\_START: { "round": 1, "your\_cards": \[CardDefinition, ...\], "timeout\_seconds": 45 }  
* OPPONENT\_COMMITTED: { "status": "ready" } (Sent when opponent locks in move)  
* TURN\_RESULT:  
  {  
    "result": TurnResult,  
    "new\_environment": "...",  
    "player\_hp\_remaining": 85,  
    "opponent\_hp\_remaining": 60  
  }

* GAME\_OVER:  
  {   
    "winner\_id": "...",   
    "reason": "HP\_ZERO" | "DISCONNECT",  
    "rating\_update": { "old": 1200, "new": 1225, "delta": \+25 }  
  }

## **10\. Project Directory Structure (AI Blueprint)**

/prompt-wars  
  /backend  
    /app  
      /api          \# FastAPI Routes (endpoints.py, leaderboard.py)  
      /core         \# Config (settings.py)  
      /logic        \# Game Rules, Elo Calculation  
      /models       \# Pydantic Schemas  
      /providers    \# LLM Adapter Implementations  
         \_\_init\_\_.py  
         base.py    \# abstract class LLMProvider  
         openai.py  \# OpenAIProvider (handles Ollama too)  
         gemini.py  \# GeminiProvider  
      /services     \# Redis wrapper, Card Dealer, JudgeService, RankService  
      /data         \# registry.json  
      main.py  
    Dockerfile  
    pyproject.toml  
  /frontend  
    ... (same as before)  
  docker-compose.yml  
  .env.example

## **11\. Configuration & Environment Variables**

*The system uses a Factory Pattern to load the correct LLM provider.*

**.env Example:**

\# Core  
APP\_ENV=development  
REDIS\_URL=redis://localhost:6379

\# AI Provider Selection (Options: "openai", "gemini", "local")  
LLM\_PROVIDER=openai

\# Provider: OpenAI  
OPENAI\_API\_KEY=sk-...

\# Provider: Gemini  
GEMINI\_API\_KEY=AIza...

\# Provider: Local (Ollama)  
\# Uses the OpenAI driver but points to localhost  
LOCAL\_LLM\_BASE\_URL=http://localhost:11434/v1  
LOCAL\_LLM\_MODEL=llama3

## **12\. Non-Functional Requirements (NFRs)**

*These requirements define system quality attributes and must be respected by the implementation.*

### **12.1 Performance & Latency**

* **Processing Budget:** The "Processing Phase" (LLM Arbitration) must complete within **5 seconds** for 95% of requests.  
* **WebSocket Latency:** Message propagation (e.g., locking in a move) must occur under **100ms**.  
* **Rendering:** PixiJS particle effects must maintain **60 FPS** on mid-range mobile devices (iPhone 12 equivalent).  
* **Concurrent Matches:** MVP must support **100 concurrent matches** (200 connected sockets) on a single Azure Container App instance (0.5 vCPU).

### **12.2 Reliability & Fault Tolerance**

* **LLM Circuit Breaker:** If the LLM provider fails (timeout \> 8s or 500 error), the system must fallback to a **Rule-Based Engine** (e.g., Simple Rock-Paper-Scissors logic) to resolve the turn, preventing game freeze.  
* **State Recovery:** If a server container crashes, the game state must persist in Redis. A new container must be able to resume the match seamlessly via room\_id.  
* **Reconnection:** Clients must automatically attempt to reconnect to WebSocket if disconnected (Exponential Backoff: 1s, 2s, 5s).

### **12.3 Security (LLM Specific)**

* **Prompt Injection Defense:** The JudgeService must sanitize user inputs to strip system-level commands (e.g., "Ignore previous instructions"). The System Prompt must strictly enforce the "Referee" role.  
* **Input Rate Limiting:** API submit\_turn is limited to 1 request per turn-phase to prevent cost spikes or abuse.  
* **Auth:** Basic Token Authentication for WebSocket connections to prevent session hijacking.

### **12.4 Cost Efficiency**

* **Token Optimization:** LLM Output must be capped at **max\_tokens=250** (JSON only). No verbose explanations unless requested.  
* **Stateless Scaling:** The architecture must allow scaling down to 0 instances when no players are active (Serverless/Container Apps).

### **12.5 Cross-Platform & Usability**

* **Mobile First:** UI must be touch-friendly with hit targets \>44px. Text input must handle virtual keyboards without obscuring the combat log.  
* **Accessibility:** All text logs must be readable by screen readers (ARIA live regions for BattleLog).

## **13\. Progression & Ranking System**

*How the game handles long-term competition.*

### **13.1 Elo Rating System**

* **Starting Rank:** All new players start at **1200**.  
* **K-Factor:** 32 (Standard volatility).  
* **Calculation:** Standard Elo formula applied on GAME\_OVER.  
  * $R\_a' \= R\_a \+ K(S\_a \- E\_a)$  
  * Where $S\_a$ is Actual Score (1 for win, 0 for loss) and $E\_a$ is Expected Score.

### **13.2 Data Persistence (Redis Strategy)**

* **Ephemeral:** Game State (Room data) expires after 1 hour.  
* **Persistent:** User Ranks are stored in a **Redis Sorted Set (ZSET)**.  
  * Key: leaderboard:global  
  * Score: elo\_rating  
  * Member: player\_id  
* **Metadata:** A separate Hash user:{id} stores { wins: 5, losses: 2, name: "Player1" }.

### **13.3 API Endpoints**

* GET /api/leaderboard: Returns top 100 players from ZSET (Reverse Range).  
* GET /api/profile/{id}: Returns Elo, W/L record.

## **14\. Implementation Roadmap (The Walking Skeleton)**

*Detailed Execution Guide: Building the full stack one slice at a time.*

Strategy: The "Walking Skeleton" (Tracer Bullet Development)  
Goal: Reach a playable "Text Console" version in Sprint 1 to validate the LLM mechanics.

### **Phase 1: The Walking Skeleton (Infrastructure)**

*Objective: Get the entire architectural stack running locally with Docker Compose. Ensure Frontend talks to Backend via WebSockets and Backend talks to Redis.*

**Step 1: Repo & Docker Setup**

* **Tasks:**  
  1. Create folder structure as defined in Section 10\.  
  2. **Backend:** Init FastAPI with Poetry. Add redis, pydantic, uvicorn.  
  3. **Frontend:** Init Vite \+ React \+ Tailwind.  
  4. **Infra:** Create docker-compose.yml (Backend \+ Frontend \+ Redis).  
  5. **Test:** Create /health endpoint and verify Redis connection.

**Step 2: The WebSocket "Echo" Loop**

* **Tasks:**  
  1. **Backend:** Create app/api/websockets.py. Implement basic ConnectionManager.  
  2. **Protocol:** Implement JOIN\_ROOM event (Mocked).  
  3. **Frontend:** Create useGameSocket hook.  
  4. **Test:** Validate cross-browser message propagation.

### **Phase 2: The Core "Text" Loop (MVP Playable)**

*Objective: A playable text-based game. This validates the "Fun Factor".*

**Step 3: The Data Contract (Strict Pydantic)**

* **Tasks:**  
  1. Create backend/app/models/schemas.py. Copy models from Section 6\.  
  2. Create backend/app/data/registry.json with the 20 cards from Section 8\.

**Step 4: The LLM Adapter (The Brain)**

* **Tasks:**  
  1. Create app/providers/base.py and openai.py.  
  2. **Test:** Create scripts/test\_judge.py. Ensure valid JSON output from LLM.

**Step 5: Connecting the Loop**

* **Tasks:**  
  1. **Backend:** Implement GameService.process\_turn() (Logic, Redis update, Broadcast).  
  2. **Frontend:** Build UI (Cards, Input, Battle Log).  
  3. **Test:** Play a full game against yourself.

### **Phase 3: The Visuals (PixiJS)**

*Objective: Replace the text log with the "Sandbox" experience.*

**Step 6: The "Universal Emitter"**

* **Tasks:**  
  1. Frontend: Install @pixi/react.  
  2. Create \<ParticleEmitter config={...} /\>.  
  3. Integration: Map TURN\_RESULT.visuals to Pixi props.

### **Phase 4: Matchmaking & Scale**

*Objective: Persistence and automated pairing.*

**Step 7: Redis ZSETs & Queues**

* **Tasks:**  
  1. Implement MatchmakingService using Redis Lists (lpush, brpop).  
  2. Implement Elo calculation.  
  3. Add leaderboard endpoint.

Developer "System Prompt" for this Roadmap  
Copy/Paste this to your AI Assistant to start Phase 1:  
"I am acting as the Lead Developer. We are executing the 'Implementation Roadmap' for Prompt Wars.  
We will start with Phase 1, Step 1 (Repo & Docker Setup).  
Please generate the project file structure, the docker-compose.yml, the pyproject.toml, and package.json.  
Ensure the docker-compose file sets up a shared network and volume for Redis."